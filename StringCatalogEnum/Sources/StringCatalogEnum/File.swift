//
//  File.swift
//  
//
//  Created by Anish Gupta on 11/24/23.
//
//

import ArgumentParser
import Foundation

struct StringCatalogEnumRefactor: ParsableCommand {
    enum Error: Swift.Error {
        case unexpectedJSON(message: String? = nil)
    }

    enum Keyword: String, CaseIterable {
        case `continue`, `default`
    }

    @Option(name: .long, help: "Full path and filename of the 'xcstrings' file.")
    var xcstringsPath: String

    @Option(name: .long, help: "Full path and filename of the generated Swift file.")
    var outputFilename: String

    @Option(name: .long, help: "Generated enum name.")
    var enumName: String = "XcodeStringKey"

    @Option(name: .long, help: "A typealias of the generated enum name.")
    var enumTypealias: String = "XCS"

    func run() throws {
        let fileManager = FileManager()
        let jsonData = try fileManager.readDataFromFile(xcstringsPath)
        let parser = JSONParser()
        let stringsDictionary = try parser.parseJSON(jsonData)
        let codeGenerator = EnumCodeGenerator(enumName: enumName, enumTypealias: enumTypealias)
        let enumCode = codeGenerator.generateEnumCode(from: stringsDictionary)
        try fileManager.writeOutput(to: outputFilename, content: enumCode)
    }
}

class FileManager {
    func readDataFromFile(_ path: String) throws -> Data {
        let fileURL = URL(fileURLWithPath: path)
        do {
            let data = try Data(contentsOf: fileURL)
            return data
        } catch {
            throw error
        }
    }

    func writeOutput(to filename: String, content: String) throws {
        let fileURL = URL(fileURLWithPath: filename)
        do {
            try content.write(to: fileURL, atomically: true, encoding: .utf8)
        } catch {
            throw error
        }
    }
}

class JSONParser {
    func parseJSON(_ data: Data) throws -> [String: Any] {
        do {
            let jsonObject = try JSONSerialization.jsonObject(with: data, options: [])
            guard let dictionary = jsonObject as? [String: Any] else {
                throw StringCatalogEnum.Error.unexpectedJSON(message: "Data is not a JSON dictionary")
            }
            return dictionary
        } catch {
            throw error
        }
    }
}


class EnumCodeGenerator {
    var enumName: String
    var enumTypealias: String

    init(enumName: String, enumTypealias: String) {
        self.enumName = enumName
        self.enumTypealias = enumTypealias
    }

    func generateEnumCode(from dictionary: [String: Any]) -> String {
        var enumCode = """
            // This file is generated by XcodeStringEnum. Please do *NOT* update it manually.
            // As a common practice, swiftLint is disabled for generated files.
            // swiftlint:disable all

            import SwiftUI

            /// Makes it a bit easier to type.
            typealias \(enumTypealias) = \(enumName)

            /// Generated by StringCatalogEnum, this enum contains all existing String Catalog keys.
            enum \(enumName): String, CaseIterable {
            """

        var cases = [String]()
        for (key, _) in dictionary {
            guard let name = convertToVariableName(key: key) else {
                continue
            }
            if StringCatalogEnum.Keyword.allCases.map({ $0.rawValue }).contains(name) {
                cases.append("    case `\(name)`\n")
            } else {
                cases.append("    case \(name)\n")
            }
        }

        cases.sort()
        cases.forEach { string in
            enumCode += string
        }

        enumCode += """
            }
            // swiftlint:enable all
            """

        return enumCode
    }

    private func convertToVariableName(key: String) -> String? {
        var result = key.components(separatedBy: CharacterSet.letters.union(CharacterSet.alphanumerics).inverted).joined()

        while !result.isEmpty {
            let firstLetter = result.prefix(1)
            let digitsCharacters = CharacterSet(charactersIn: "0123456789")
            if CharacterSet(charactersIn: String(firstLetter)).isSubset(of: digitsCharacters) {
                result = String(result.dropFirst())
            } else {
                break
            }
        }

        guard !result.isEmpty else {
            return nil
        }

        guard result.count > 1 else {
            return result.lowercased()
        }

        let firstLetter = result.prefix(1).lowercased()
        let remainingLetters = result.dropFirst()
        result = firstLetter + remainingLetters

        return result
    }
}
